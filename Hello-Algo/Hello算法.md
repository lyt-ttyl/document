# HELLO ALGO

[在线阅读](https://www.hello-algo.com/chapter_hello_algo/)

![img](https://www.hello-algo.com/chapter_preface/suggestions.assets/learning_route.png)

## 第一章 认识算法

### 1.1生活中的算法

- 二分查找：查字典，有序数组
- 插入排序：整理扑克，处理小型数据集时非常高效
- 贪心：超市找零

### 1.2 算法的定义

- 算法：在有限时间内解决特定问题的一组指令或操作步骤
- 算法特性：
  - 问题是明确的（有清晰的输入和输出定义）
  - 具有可行性，能够在有限的步骤、时间、空间下完成
  - 各步骤都有明确的含义，在相同的输入和运行条件下，输出始终相同

- 数据结构：组织和存储数据的方式，涵盖数据内容、数据之间的关系和数据操作方法
- 设计目标
  - 空间占用尽量少
  - 数据操作尽可能快速
  - 提供简洁的数据表示和逻辑信息，以便算法高效运行

**数据结构设计是一个充满权衡的过程**。

数据结构与算法，简称算法。

LeeCode其实考的知识点是：数据结构、算法。



## 第二章 复杂度分析

### 2.1 算法效率评估

- 算法设计目标：**既快又省**
  - 找到问题解法
  - 寻求最优解（时间效率、空间效率）

- 效率评估方法
  - 实际测试：有较大的局限性
  - 理论估算：**渐进复杂度分析**（简称：复杂度分析）
- 复杂度分析：**描述了随着输入数据大小的增加，算法所需的时间和空间的增长趋势**

### 2.2 迭代和递归

迭代、递归（两种基本的程序控制结构）实现重复执行任务

#### 迭代

- 一定的条件下重复执行某段代码，直到这个条件不再满足
- for循环：
  - **适合在预先知道迭代次数时使用**
  - 代码更紧凑
- while循环：
  - 程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环
  - 更加灵活
- 嵌套循环
  - 添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推

#### 递归

- 一种算法策略，通过函数调用自身来解决问题
- 递归三要素
  - 终止条件：用于决定什么时候 “递”  转 “归”。
  - 递归调用
  - 返回结果

```js
/* 递归 */
function recur(n) {
    // 终止条件
    if (n === 1) return 1;
    // 递：递归调用
    const res = recur(n - 1);
    // 归：返回结果
    return n + res;
}
```

#### 迭代 与 递归

迭代与递归特点对比

|          | 迭代                                   | 递归                                                         |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| 实现方式 | 循环结构                               | 函数调用自身                                                 |
| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |
| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |

$$
例如：(1)例如：f(n)=1+2+...+n
$$

- 迭代：从最基础的步骤开始，不断重复或累加，直至任务完成
  - 从 1遍历到 n，每轮执行求和操作

- 递归：将原问题分解成更小的子问题，子问题与原问题形式相同，子问题继续分解，直至基本情况为止。
  - f(n) = n + f(n-1),   f(n-1) = n-1 + f(n-2), 不断分解，直到 f(1) = 1
  - 递归通常比迭代更加耗费内存空间
  - 递归通常比循环的时间效率更低
  - 尾递归：**函数在返回前的最后一步才进行递归调用**，空间效率上与迭代相当。
  - 递归树：处理”分治“相关算法问题，递归更直观，如 “斐波那契数列”

```js
// 尾递归
function tailRecur(n, res) {
	// 终止条件
	if (n === 0) return res
  // 尾递归调用
  return tailRecur(n - 1, res + n)
}
```

> 例题：给定一个斐波那契数列 0,1,1,2,3,5,8,13,… ，求该数列的第 𝑛 个数字。
> $$
> f(1) = 0
> $$
>
> $$
> f(2) = 1
> $$
>
> $$
> f(n) = f(n-1) + f(n-2)
> $$
>
> ```js
> function fib(n) {
>   // 终止条件 f(1) = 0, f(2) = 1
>   if (n === 1 || n ===2) return n-1
>   // 递归调用
>   const res = fib(n-1) + fib(n-2)
>   return res
> }
> ```
>
> ![斐波那契数列的递归树](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png)

### 2.3 时间复杂度

- 时间复杂度分析
  - 本质上是计算“操作数量”的渐近上界

- 函数渐进上限
  - 若存在正实数 𝑐 和实数 𝑛0 ，使得对于所有的 𝑛>𝑛0 ，均有 𝑇(𝑛)≤𝑐⋅𝑓(𝑛) ，则可认为 𝑓(𝑛) 给出了 𝑇(𝑛) 的一个渐近上界，记为 𝑇(𝑛)=𝑂(𝑓(𝑛)) 。
- 推算方法
  1. 统计操作数量
     1. 从上到下，逐行计算
     2. 忽略 𝑇(𝑛) 中的系数和常数
     3. **循环嵌套时使用乘法**，总操作数量等于外层循环和内层循环操作数量之积，每一层循环操作参考1和2
  2. 判断渐近上界
     1. **时间复杂度由 𝑇(𝑛) 中最高阶的项来决定**。因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。

```js
// 统计操作数量 𝑇(𝑛) = n*n + n
function algorithm(n) {
    let a = 1;  // +0（技巧 1）
    a = a + n;  // +0（技巧 1）
    // +n（技巧 2）
    for (let i = 0; i < 5 * n + 1; i++) {
        console.log(0);
    }
    // +n*n（技巧 3）
    for (let i = 0; i < 2 * n; i++) {
        for (let j = 0; j < n + 1; j++) {
            console.log(0);
        }
    }
}
```

时间复杂度：𝑂(𝑛^2^)

#### 常见时间复杂度类型

$$
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)
$$

常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 指数阶 < 阶乘阶

![常见的时间复杂度类型](https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_common_types.png)

n：输入数据大小 /  输入的数组或链表长度 / n轮 

- 常数阶：与n无关
- 对数阶 *O(logn)*
  - 反映了“每轮缩减到一半”的情况
  - 比如：循环里有 n = n/2
  - 递归函数
  - 基于分治策略的算法：“一分为多”和“化繁为简”
- 线性阶:  单层循环
- 线性对数阶 *O(nlogn)*
  - 两层嵌套循环，时间复杂度分别为 *O(logn)* 和 *O(n)*
  - 主流排序算法：快速排序、归并排序、堆排序
- 平方阶：双层循环
- 指数阶：
  - 细胞分裂、递归函数（其递归地一分为二，经过 𝑛 次分裂后停止）
  - 穷举法（暴力搜索、回溯等）
  - 不适合大规模数据
- 阶乘阶 *O(n!)*
  - 全排列、递归
  - 当 𝑛≥4 时恒有 𝑛!>2^𝑛^ ，不适合大规模数据

#### 最差、最佳、平均时间复杂度

- 最差**𝑂(𝑛) ** ，给出了**效率安全值** ，常用
- 最佳 **Ω(1)** 
- 平均

### 2.4 空间复杂度

- 用于衡量算法占用内存空间随着数据量变大时的**增长趋势**
- 一般情况下，**空间复杂度 = 暂存空间（暂存数据 + 栈帧空间） + 输出空间**
- 算法相关空间：
  - 输入空间
  - 暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据
    - 暂存数据：各种常量、变量、对象
    - 栈帧空间：每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
    - 指令空间：忽略不计
  - 输出空间

- **最差空间复杂度**
  - **以最差输入数据为准**
  - **以算法运行中的峰值内存为准**

$$
O(1) < O(logn) < O(n) < O(n^2) < O(2^n)
$$

常数阶 < 对数阶 < 线性阶 < 平方阶 < 指数阶v

- 注意事项

  - **在递归函数中，需要注意统计栈帧空间

  - 常数阶：在**循环中**初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 𝑂(1) ：
  - 线性阶：元素数量与 𝑛 成正比的数组、链表、栈、队列等：尾递归通常认为*O(n)*
  - 平方阶：矩阵、图，元素数量与 n 成平方关系
  - 指数阶：二叉树
  - 对数阶：分治，如 归并排序。将数字转化为字符串
